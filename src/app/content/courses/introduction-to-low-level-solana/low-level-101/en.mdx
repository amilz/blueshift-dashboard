import { ArticleSection } from "../../../../components/ArticleSection/ArticleSection";
import { Codeblock } from "../../../../components/Codeblock/Codeblock";

# Low-level 101

![Image Test](/graphics/banners/research-crateless-program.png)

If you have written a Solana program, you definitely know that all the basic needs for a program like an Entrypoint, CPIs, and account management are usually handled by crates like solana_program and pinocchio, which are used under the hood by frameworks like anchor, steel, ...

But to truly understand and optimize the Solana stack, we need to peek behind all these abstraction and see what happens under the hood. In this course, we're going to create a fully hand-rolled, zero-dependency Solana program from scratch.

Before we look at the different hand-rolled component, we need to understand the fundamental building blocks that make Solana programs work.

<ArticleSection name="eBPF" id="eBPF" level="h2" />

Solana programs compile to eBPF (extended Berkeley Packet Filter) bytecode, not native machine code. This architectural choice explains many Solana quirks:
- **Compute unit limits**: eBPF's safety model prevents infinite loops by counting instructions
- **No heap allocation**: eBPF programs run in a sandboxed environment without malloc/free
- **Limited stack**: Only 4KB of stack space forces careful memory management
- **Deterministic execution**: The same inputs always produce the same outputs across all validators

This explain why certain Rust features simply don't work in Solana programs; the runtime literally cannot execute them.

<ArticleSection name="#[repr(C)] & extern `C`" id="repr-c-and-extern-c" level="h2" />

When you look at any low-level Solana example, two patterns appear everywhere:

```rust
#[repr(C)]              
pub struct MyState { … }

pub unsafe extern "C" fn entrypoint(ptr: *mut u8) -> u64 { … }
```

**`extern "C"`**

Tells the Rust compiler to expose a function using the C ABI (Application Binary Interface), the calling convention that defines which eBPF registers carry arguments, how the stack is laid out and which register returns values.

The C ABI is chosen because it's the lowest common denominator across every language that LLVM's eBPF backend supports: Rust, C, Zig, or even hand-written assembly. The Solana runtime needs to call your program's entrypoint by raw name and pass parameters through specific registers; the C ABI guarantees this works regardless of which language compiled your bytecode.

**`#[repr(C)]`** 

Forces Rust to arrange struct fields exactly as a C compiler would, locking field order and padding so the byte layout never changes:

```rust
// Without #[repr(C)] - Rust can reorder these fields for optimization!
struct UnpredictableState {
    amount: u64,     // Could be at offset 0, 8, or 16
    owner: [u8; 32], // Position depends on compiler mood
    bump: u8,        // Might get packed or padded anywhere
}

// With #[repr(C)] - Layout is guaranteed and predictable
#[repr(C)]
struct PredictableState {
    amount: u64,     // Always at offset 0
    owner: [u8; 32], // Always at offset 8  
    bump: u8,        // Always at offset 40
    // Implicit padding: 7 bytes to align to 8-byte boundary
}
```

This matters because account data persists between program invocations. If Rust reorders your fields between compilations, your program won't be able to read data it wrote previously.

<ArticleSection name="Memory Layout Management" id="memory-layout-management" level="h2" />

In high-level frameworks, memory alignment happens automatically. At the low level, every byte counts:

```rust
rust#[repr(C)]
struct BadAlignment {
    flag: u8,        // 1 byte
    // Compiler inserts 7 bytes of padding here
    amount: u64,     // 8 bytes - needs 8-byte alignment!
    owner: [u8; 32], // 32 bytes
} // Total: 48 bytes (not 41!)

#[repr(C)]  
struct GoodAlignment {
    amount: u64,     // 8 bytes - naturally aligned
    owner: [u8; 32], // 32 bytes  
    flag: u8,        // 1 byte
    // Only 7 bytes of padding at the end
} // Total: 48 bytes, but padding is predictable
```

The rule for memory management is that each field must start at an offset divisible by its own size:
- `u8`: Any offset (divisible by 1)
- `u16`: Offset must be divisible by 2 (0, 2, 4...)
- `u32`: Offset must be divisible by 4 (0, 4, 8...)
- `u64`: Offset must be divisible by 8 (0, 8, 16...)

This is really important because mismanaging memory can lead to misaligned memory access that can cause your program to fail unpredictably. 

When you're manually managing account data serialization, understanding padding and alignment becomes crucial for cross-program compatibility.








#### Syscalls 

A **system call**, or syscall, is the doorway through which unprivileged code requests a privileged service from its host. When a syscall is made, the CPU switches from user mode to a trusted, privileged mode; the runtime then performs the requested action, and control returns with a status code. This indirection keeps sandboxed code from touching host memory or I/O directly, preserving safety and determinism.

On Solana, BPF bytecode cannot hash, log, or perform a cross-program invocation (CPI) on its own. Instead, it invokes named syscalls such as `sol_log`, `sol_sha256`, `sol_invoke_signed`.

Each syscall number is simply an index in the loader's dispatch table. The loader executes the requested operation and returns a `u64` status word (zero for success, non-zero for failure).

For example, `sol_invoke_signed` packages an instruction, its account list, and any PDA signer seeds, hands them to the loader, and the loader performs the CPI under the proper authority like this:

```rust
/// Solana BPF syscall for invoking a signed instruction.
fn sol_invoke_signed_c(
    instruction_addr: *const u8,
    account_infos_addr: *const u8,
    account_infos_len: u64,
    signers_seeds_addr: *const u8,
    signers_seeds_len: u64,
) -> u64;
```

<ArticleSection name="The Vault Code" id="the-vault-code" level="h2" />

Now that we've unpacked every building block of a "crate-less" Solana program, we can outline the vault itself. Remember, a vault does exactly two things:
- **Deposit** lamports into a PDA derived from the owner's public key.
- **Withdraw** those same lamports later; only by the owner.

Each instruction will therefore carry three accounts:
- **Owner** (signer, writable): The user depositing or withdrawing funds.
- **Vault** (writable): A PDA where all the lamports are contained.
- **System Program**: account needed to performs the lamport transfer.

Before starting we need to create a new project, to do so run this command in your terminal:

```
# create workspace
cargo new blueshift_vault --lib --edition 2021
cd blueshift_vault
```

In `Cargo.toml` add:

```
[lib]
crate-type = ["lib", "cdylib"]
```

#### Template 

Everything will live in `lib.rs`. At a glance, the file will contain Syscall Shims (tiny, #[repr(C)] structs that mirror the raw syscall layouts we'll need), and data offsets as constants (to make it easier to work with raw data).

```rust
#![no_std]

const ACCOUNT_RAW_LEN: usize = 10_336;
const INSTRUCTION_LEN_LEN: usize = 8;

const ACCOUNT_OFFSET: usize = 8;
const IS_DUPLICATE_OFFSET: usize = 0;
const IS_SIGNER_OFFSET: usize = 1;
const IS_WRITABLE_OFFSET: usize = 2;
const EXECUTABLE_OFFSET: usize = 3;
const ALIGNMENT_OFFSET: usize = 4;
const KEY_OFFSET: usize = 8;
const OWNER_OFFSET: usize = 40;
const LAMPORTS_OFFSET: usize = 72;
const DATA_LEN_OFFSET: usize = 80;
const DATA_OFFSET: usize = 88;
const PADDING_OFFSET: usize = 10_248;
const RENT_EPOCH_OFFSET: usize = 10_248;

// Base58 encoded to 11111111111111111111111111111111
const SYSTEM_PROGRAM_ID: [u8; 32] = [0u8; 32];

#[allow(unused)]
extern "C" { 
    fn sol_sha256(
        vals: *const u8, 
        val_len: u64, 
        hash_result: *mut [u8;32]
    ) -> u64;

    fn sol_log_(
        input: *const u8, 
        len: u64
    ) -> u64;

    fn sol_log_64_(
        arg1: u64, 
        arg2: u64, 
        arg3: u64, 
        arg4: u64, 
        arg5: u64
    ) -> u64;

    fn sol_invoke_signed_c(
        instruction_addr: *const u8,
        account_infos_addr: *const u8,
        account_infos_len: u64,
        signers_seeds_addr: *const u8,
        signers_seeds_len: u64,
    ) -> u64;
}

#[repr(C)]
struct SolInstruction {
    program_id_addr: u64,
    accounts_addr: u64,
    accounts_len: usize,
    data_addr: u64,
    data_len: usize,
}

#[repr(C)]
struct SolAccountMeta {
    pubkey_addr: u64,
    is_writable: bool,
    is_signer: bool,
}

#[repr(C)]
struct SolAccountInfo {
    key_addr: u64,
    lamports_addr: u64,
    data_len: u64,
    data_addr: u64,
    owner_addr: u64,
    rent_epoch: u64,
    is_signer: bool,
    is_writable: bool,
    executable: bool,
}

#[repr(C)]
struct SolSignerSeed {
    seed: *const u8,
    seed_len: u64,
}

#[repr(C)]
struct SolSignerSeedC {
    addr: u64,
    len: u64,
}

#[repr(C)]
struct SolSignerSeedsC {
    addr: u64,
    len: u64,
}

// 22222222222222222222222222222222222222222222
pub const ID: [u8; 32] = [
    0x0f, 0x1e, 0x6b, 0x14, 0x21, 0xc0, 0x4a, 0x07, 
    0x04, 0x31, 0x26, 0x5c, 0x19, 0xc5, 0xbb, 0xee, 
    0x19, 0x92, 0xba, 0xe8, 0xaf, 0xd1, 0xcd, 0x07, 
    0x8e, 0xf8, 0xaf, 0x70, 0x47, 0xdc, 0x11, 0xf7, 
];

#[no_mangle]
pub unsafe extern "C" fn entrypoint(input: *mut u8) -> u64 {

}
```

#### Account Checks

Before we can run `deposit` or `withdraw`, the entrypoint has to be sure the transaction gave us exactly the right accounts and that each one has the expected flags.

Because we're working at the raw pointer level, every check is done with simple pointer math and direct loads.

The first eight bytes of the input record hold account_len. For this vault we expect three accounts: owner, vault PDA, and the System Program:

```rust
// Check that we have 3 accounts: Signer, Vault, Program
if *(input as *const u64) != 3 {
    sol_log_("Invalid number of accounts".as_ptr(), 26);
    return 1010; // NotEnoughAccountKeys Error
}
```


We continue by checking each account, the layout offsets we defined earlier let us sanity-check every flag without deserializing the full struct.

For the first account, the signer, these are the checks that we perform: 
- Must be unique (is_duplicate == 0xff)
- Writable (we'll change its lamports)
- Signer
- Not executable
- Must have no data 

```rust
if *(input.add(ACCOUNT_OFFSET) as *const u32) != 0x0101ff {
    sol_log_("Invalid Account 1 Data: Non-Duplicate, Writable, Signer, Non-Executable Check Failed".as_ptr(), 58);
    return 1003; // InvalidAccountData Error
}
if *(input.add(ACCOUNT_OFFSET + DATA_LEN_OFFSET) as *const usize) != 0 {
    sol_log_("Invalid Account 1 Data: Data Length is not 0".as_ptr(), 38);
    return 1003; // InvalidAccountData Error
}
```

We also stash the owner's public key for the PDA check later:

```rust
let signer_key = *(input.add(ACCOUNT_OFFSET + KEY_OFFSET) as *const [u8; 32]);
```

For the second account, the vault, these are the checks that we perform:
- Writable (we'll change its lamports)
- Owned by the System Program
- Data length must be zero (we don't store state here)

```rust
const ACCOUNT_2_OFFSET: usize = ACCOUNT_OFFSET + ACCOUNT_RAW_LEN;

if *(input.add(ACCOUNT_2_OFFSET + IS_WRITABLE_OFFSET) as *const u8) != 1 {
    sol_log_("Invalid Account 2 Data: Writable Check Failed".as_ptr(), 38);
    return 1003; // InvalidAccountData Error
}

if *(input.add(ACCOUNT_2_OFFSET + OWNER_OFFSET) as *const [u8; 32]) != pinocchio_system::ID {
    sol_log_("Invalid Account 2 Data: Owner is not the System Program".as_ptr(), 48);
    return 1022; // InvalidAccountOwner Error
}

if *(input.add(ACCOUNT_2_OFFSET + DATA_LEN_OFFSET) as *const usize) != 0 {
    sol_log_("Invalid Account 2 Data: Data Length is not 0".as_ptr(), 38);
    return 1003; // InvalidAccountData Error
}
```

We also grab the vault's public key for the PDA check later:

```rust
let vault_key = *(input.add(ACCOUNT_2_OFFSET + KEY_OFFSET) as *const [u8; 32]);
```

For the last account, the system program, these are the checks that we perform: 
- Must be executable
- Its key must equal SYSTEM_PROGRAM_ID

```rust
const ACCOUNT_3_OFFSET: usize = ACCOUNT_2_OFFSET + ACCOUNT_RAW_LEN;
const SYSTEM_PROGRAM_DATA_LENGTH: usize = 14 + 2;

if *(input.add(ACCOUNT_3_OFFSET + EXECUTABLE_OFFSET) as *const u8) != 1 {
    sol_log_("Invalid Account 3 Data: Executable Check Failed".as_ptr(), 38);
    return 1003; // InvalidAccountData Error
}

if *(input.add(ACCOUNT_2_OFFSET + OWNER_OFFSET) as *const [u8; 32]) != SYSTEM_PROGRAM_ID {
    sol_log_("Invalid Account 3 Data: Owner is not the System Program".as_ptr(), 48);
    return 1003; // InvalidAccountData Error
}
```

#### Instruction checks

After account validation, we can finally parse the instruction payload. And we take the same approach as a native program by using the first byte as the discriminator:

```rust
const INSTRUCTION_OFFSET: usize = ACCOUNT_3_OFFSET + ACCOUNT_RAW_LEN + SYSTEM_PROGRAM_DATA_LENGTH + INSTRUCTION_LEN_LEN;

let discriminator = *(input.add(INSTRUCTION_OFFSET) as *const u8);
match discriminator {
    0 => {
        sol_log_("Deposit".as_ptr(), 7);

        // deposit logic …

        return 0; // Success
    }
    1 => {
        sol_log_("Withdraw".as_ptr(), 8);

        // withdraw logic …

        return 0; // Success
    }
    _ => {
        sol_log_("Invalid Instruction".as_ptr(), 20);
        return 1002; // InvalidInstructionData Error
    }
}
```

From here we branch into either the deposit or withdraw handler, confident that every account and flag is exactly what the vault expects.

#### Deposit Logic

We will start with a tighter walkthrough of the deposit instruction. All checks sit up front; once they pass, we craft a System-Program transfer and invoke it.

The instruction data of this instruction looks like this:
- Byte 0 is the discriminator (`0x00` for deposit).
- Byte 1 is the bump you'll reuse for the PDA check.
- Bytes 2-9 hold the lamport amount in little-endian that will be checked and rejected if it amounts for 0.

```rust
let amount = *(input.add(INSTRUCTION_OFFSET + 2) as *const u64);
if amount == 0 {
    return 1002; // InvalidInstructionData Error
}
```

After that we hash the owner key using the `sol_sha256` syscall, with the bump, the program ID and the unique string "ProgramDerivedAddress". 

We compare the result with the vault key we stashed during the account checks. If they differ, it return `InvalidSeeds`.

If they differ, it return `InvalidSeeds`.

```rust
let bump: u8 = *(input.add(INSTRUCTION_OFFSET + 1) as *const u8);
let data = [
    signer_key.as_ref(),
    &[bump],
    ID.as_ref(),
    b"ProgramDerivedAddress",
];

let mut pda = core::mem::MaybeUninit::<[u8; 32]>::uninit();
sol_sha256(
    &data as *const _ as *const u8,
    4,
    pda.as_mut_ptr(),
);

if vault_key != *pda.as_ptr() {
    sol_log_("Invalid PDA address".as_ptr(), 19);
    return 1013; // InvalidSeeds Error
};
```

Lastly we can finally craft the System-Program transfer. 

The System Program uses a four-byte discriminator (for transfer that value is 2) and require an additional 8 bytes that represent the amount that we want to transfer from the `from_account` to the `to_account`

We then need to build a tiny array of two SolAccountMeta values: from = owner (signer, writable), to = vault (writable). We combine that with the `instruction_data` to create a `SolInstruction` struct:

```rust
let mut instruction_data = [0; 12];
instruction_data[0] = 2; // discriminator
instruction_data[4..12].copy_from_slice(&amount.to_le_bytes()); // amount

let accounts_addr: [SolAccountMeta; 2] = [
    // from_account
    SolAccountMeta { 
        pubkey_addr: input.add(ACCOUNT_OFFSET + KEY_OFFSET) as u64,
        is_writable: true,
        is_signer: true,
    },
    // to_account
    SolAccountMeta { 
        pubkey_addr: input.add(ACCOUNT_2_OFFSET + KEY_OFFSET) as u64,
        is_writable: true,
        is_signer: false,
    },
];

// Create the instruction
let instruction = SolInstruction {
    program_id_addr: input.add(ACCOUNT_3_OFFSET + KEY_OFFSET) as u64,
    accounts_addr: accounts_addr.as_ptr() as u64,
    accounts_len: 2,
    data_addr: instruction_data.as_ptr() as u64,
    data_len: 12,
};
```

But before calling the `sol_invoke_signed_c` syscall we need to build two `SolAccountInfo` structs, one for the owner and one for the
vault that supplies pointers to their lamport balances and data slices exactly where the loader left them in memory.

After that we can call the syscall by passing the instruction pointer, the pointer to your two-element `SolAccountInfo` array, and the account count (2). Because the outer transaction is already signed by the owner, no PDA seeds are needed here, so the `signers_seeds_addr` argument is NULL.

```rust
let account_infos_addr: [SolAccountInfo; 2] = [
    SolAccountInfo {
        is_signer: true,
        is_writable: true,
        executable: false,
        key_addr: input.add(ACCOUNT_OFFSET + KEY_OFFSET) as u64,
        lamports_addr: input.add(ACCOUNT_OFFSET + LAMPORTS_OFFSET) as u64,
        data_len: 0,
        data_addr: input.add(ACCOUNT_OFFSET + DATA_OFFSET) as u64,
        owner_addr: input.add(ACCOUNT_OFFSET + OWNER_OFFSET) as u64,
        rent_epoch: 0,
    },
    SolAccountInfo {
        is_signer: false,
        is_writable: true,
        executable: false,
        key_addr: input.add(ACCOUNT_2_OFFSET + KEY_OFFSET) as u64,
        lamports_addr: input.add(ACCOUNT_2_OFFSET + LAMPORTS_OFFSET) as u64,
        data_len: 0,
        data_addr: input.add(ACCOUNT_2_OFFSET + DATA_OFFSET) as u64,
        owner_addr: input.add(ACCOUNT_2_OFFSET + OWNER_OFFSET) as u64,
        rent_epoch: 0,
    },
];

// Invoke the instruction with the signer seeds
sol_invoke_signed_c(
    &instruction as *const SolInstruction as *const u8,
    account_infos_addr.as_ptr() as *const u8,
    2, // Number of accounts
    core::ptr::null(),
    0,
);
```

#### Withdraw Logic

The withdraw instruction is similar to deposit, but with a few key differences. The instruction data is simpler:
- Byte 0 is the discriminator (`0x01` for withdraw).
- Byte 1 is the bump you'll reuse for the PDA check.

```rust
let bump: u8 = *(input.add(INSTRUCTION_OFFSET + 1) as *const u8);
```

We perform the same PDA check as in deposit, using the owner's public key, bump, program ID and the unique string "ProgramDerivedAddress":

```rust
let data = [
    signer_key.as_ref(),
    &[bump],
    ID.as_ref(),
    b"ProgramDerivedAddress",
];

let mut pda = core::mem::MaybeUninit::<[u8; 32]>::uninit();
sol_sha256(
    &data as *const _ as *const u8,
    4,
    pda.as_mut_ptr(),
);

if vault_key != *pda.as_ptr() {
    sol_log_("Invalid PDA address".as_ptr(), 19);
    return 1013; // InvalidSeeds Error
};
```

The key difference in withdraw is that we need to sign the transaction with the PDA itself. To do this, we need to provide the seeds that were used to derive the PDA. We create a `SolSignerSeedsC` array with two elements:
- The owner's public key (32 bytes)
- The bump (1 byte)

```rust
let seeds: [SolSignerSeedsC; 2] = [
    SolSignerSeedsC {
        addr: input.add(ACCOUNT_OFFSET + KEY_OFFSET) as u64,
        len: 32,
    },
    SolSignerSeedsC {
        addr: input.add(INSTRUCTION_OFFSET + 1) as u64,
        len: 1,
    },
];

let signer_seeds_addr: [SolSignerSeedsC; 1] = [
    SolSignerSeedsC {
        addr: seeds.as_ptr() as u64,
        len: 2,
    },
];
```

We then craft the System Program transfer instruction, but this time from the vault to the owner. The instruction data is the same as deposit:
- Four-byte discriminator (value 2 for transfer)
- Eight bytes for the amount (which we get from the vault's lamports)

```rust
let amount = *(input.add(ACCOUNT_2_OFFSET + LAMPORTS_OFFSET) as *const u64);

let mut instruction_data = [0; 12];
instruction_data[0] = 2;
instruction_data[4..12].copy_from_slice(&amount.to_le_bytes());
```

The account metas are reversed compared to deposit:
- First account is the vault (writable, signer)
- Second account is the owner (writable)

```rust
let account_addr: [SolAccountMeta; 2] = [
    SolAccountMeta {
        pubkey_addr: input.add(ACCOUNT_2_OFFSET + KEY_OFFSET) as u64,
        is_writable: true,
        is_signer: true,
    },
    SolAccountMeta {
        pubkey_addr: input.add(ACCOUNT_OFFSET + KEY_OFFSET) as u64,
        is_writable: true,
        is_signer: false,
    },
];
```

Finally, we call `sol_invoke_signed_c` with the instruction, account infos, and the signer seeds we created earlier:

```rust
sol_invoke_signed_c(
    &instruction as *const SolInstruction as *const u8,
    account_infos_addr.as_ptr() as *const u8,
    2, // Number of accounts
    signer_seeds_addr.as_ptr() as *const u8,
    1,
);
```

<ArticleSection name="Closing Remarks" id="closing-remarks" level="h2" />

While this low-level approach to writing Solana programs might seem extreme, it serves a crucial educational purpose. We're not suggesting you write your programs this way; in fact, we strongly recommend using established frameworks and crates that abstract away these complexities. However, understanding the underlying mechanics is invaluable.

Every abstraction we use in Solana development, whether it's `solana_program`, `anchor`, or any other framework, is built on top of these fundamental building blocks. By peeling back the layers and examining the raw mechanics, we gain a deeper appreciation for:

1. How the Solana runtime interacts with our programs
2. Why certain design decisions were made in higher-level frameworks
3. Where potential optimizations might exist
4. How to better debug issues when they occur

This knowledge isn't just academic; it's practical. When you understand the foundation, you can:
- Write more efficient programs by making informed decisions about data structures and memory usage
- Better diagnose and fix issues when they arise
- Contribute to the ecosystem by improving the tools we all use
- Make informed decisions about when to use certain abstractions and when to work closer to the metal

Remember, the goal of this exercise wasn't to teach you how to write programs without crates, but rather to help you understand what those crates are doing under the hood. This understanding is the first step toward writing better, more efficient Solana programs, regardless of which tools you choose to use.
